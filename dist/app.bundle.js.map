{"version":3,"file":"app.bundle.js","mappings":"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","sources":["webpack://test-app/./node_modules/@riotjs/hot-reload/index.js","webpack://test-app/./node_modules/@riotjs/observable/dist/observable.js","webpack://test-app/./src/components/global/test-component.riot","webpack://test-app/./src/register-global-components.js","webpack://test-app/./src/index.js","webpack://test-app/./node_modules/bianco.query/index.next.js","webpack://test-app/./node_modules/bianco.dom-to-array/index.next.js","webpack://test-app/./node_modules/mini-css-extract-plugin/dist/hmr/hotModuleReplacement.js","webpack://test-app/./node_modules/mini-css-extract-plugin/dist/hmr/normalize-url.js","webpack://test-app/./src/style.css?e320","webpack://test-app/./node_modules/regenerator-runtime/runtime.js","webpack://test-app/./node_modules/riot/riot.esm.js","webpack://test-app/./src/components/global|sync|/[a-zA-Z0-9-]+/.riot"],"sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('riot'), require('bianco.query')) :\n  typeof define === 'function' && define.amd ? define(['exports', 'riot', 'bianco.query'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.riotHotReload = {}, global.riot, global.$));\n}(this, (function (exports, riot, $) { 'use strict';\n\n  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\n  var $__default = /*#__PURE__*/_interopDefaultLegacy($);\n\n  const { cssManager } = riot.__;\n  const { DOM_COMPONENT_INSTANCE_PROPERTY } = riot.__.globals;\n\n  function reload(componentAPI) {\n    const {name} = componentAPI;\n\n    if (!name) {\n      console.warn('Anonymous components can not be reloaded'); // eslint-disable-line\n      return []\n    }\n\n    return $__default['default'](`${name}, [is=${name}]`).map(el => {\n      const oldTag = el[DOM_COMPONENT_INSTANCE_PROPERTY];\n\n      // early return in case there is no riot instance found\n      if (!oldTag) return\n\n      // remove the tag template from the DOM\n      oldTag.unmount(true);\n      // delete the old css from the css manager\n      cssManager.remove(name);\n\n      // create the new tag\n      const newTag = riot.component(componentAPI)(el, oldTag.props);\n      newTag.update(oldTag.state);\n\n      return newTag\n    })\n  }\n\n  exports.default = reload;\n  exports.reload = reload;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n",";(function(window, undefined) {const ALL_CALLBACKS = '*'\nconst define = Object.defineProperties\nconst entries = Object.entries\n\nconst on = (callbacks, el) => (event, fn) => {\n  if (callbacks.has(event)) {\n    callbacks.get(event).add(fn)\n  } else {\n    callbacks.set(event, new Set().add(fn))\n  }\n\n  return el\n}\n\nconst off = (callbacks, el) => (event, fn) => {\n  if (event === ALL_CALLBACKS && !fn) {\n    callbacks.clear()\n  } else {\n    if (fn) {\n      const fns = callbacks.get(event)\n\n      if (fns) {\n        fns.delete(fn)\n        if (fns.size === 0) callbacks.delete(event)\n      }\n    } else callbacks.delete(event)\n  }\n  return el\n}\n\nconst one = (callbacks, el) => (event, fn) => {\n  function on(...args) {\n    el.off(event, on)\n    fn.apply(el, args)\n  }\n  return el.on(event, on)\n}\n\nconst trigger = (callbacks, el) => (event, ...args) => {\n  const fns = callbacks.get(event)\n\n  if (fns) fns.forEach(fn => fn.apply(el, args))\n\n  if (callbacks.get(ALL_CALLBACKS) && event !== ALL_CALLBACKS) {\n    el.trigger(ALL_CALLBACKS, event, ...args)\n  }\n\n  return el\n}\n\nconst observable = function(el) { // eslint-disable-line\n  const callbacks = new Map()\n  const methods = {on, off, one, trigger}\n\n  el = el || {}\n\n  define(el,\n    entries(methods).reduce((acc, [key, method]) => {\n      acc[key] = {\n        value: method(callbacks, el),\n        enumerable: false,\n        writable: false,\n        configurable: false\n      }\n\n      return acc\n    }, {})\n  )\n\n  return el\n}\n  /* istanbul ignore next */\n  // support CommonJS, AMD & browser\n  if (typeof exports === 'object')\n    module.exports = observable\n  else if (typeof define === 'function' && define.amd)\n    define(function() { return observable })\n  else\n    window.observable = observable\n\n})(typeof window != 'undefined' ? window : undefined);","<test-component>\r\n    <h1>test</h1> \r\n    <script>\r\n        import observable from \"@riotjs/observable\"; \r\n        \r\n            export default {\r\n                async onMounted() {\r\n                    const rawResponse = await fetch('https://httpbin.org/post', {\r\n                    method: 'POST',\r\n                    headers: {\r\n                    'Accept': 'application/json',\r\n                    'Content-Type': 'application/json'\r\n                    },\r\n                    body: JSON.stringify({a: 1, b: 'Textual content'})\r\n                });\r\n                const content = await rawResponse.json(); \r\n                console.log(content); \r\n            } \r\n        } \r\n    </script> \r\n</test-component>","import { register } from 'riot'\r\n\r\nconst basename = (path, extension = '') => path.split('/').reverse()[0].replace(extension, '')\r\nconst globalComponentsContext = require.context('./components/global/', true, /[a-zA-Z0-9-]+\\.riot/)\r\n\r\nexport default () => {\r\n  globalComponentsContext.keys().map(path => {\r\n    const name = basename(path, '.riot')\r\n\r\n    const component = globalComponentsContext(path)\r\n\r\n    register(name, component.default || component)\r\n\r\n    return {\r\n      name,\r\n      component\r\n    }\r\n  })\r\n}\r\n","import 'regenerator-runtime/runtime';\r\nimport './style.css'\r\nimport '@riotjs/hot-reload'\r\nimport '@riotjs/observable'\r\nimport { mount } from 'riot'\r\nimport registerGlobalComponents from './register-global-components'\r\n\r\n// register\r\nregisterGlobalComponents()\r\n\r\n// mount all the global components found in this page\r\nmount('[data-riot-component]')\r\n","import domToArray from 'bianco.dom-to-array'\n\n/**\n * Simple helper to find DOM nodes returning them as array like loopable object\n * @param   { string|DOMNodeList } selector - either the query or the DOM nodes to arraify\n * @param   { HTMLElement }        ctx      - context defining where the query will search for the DOM nodes\n * @returns { Array } DOM nodes found as array\n */\nexport default function $(selector, ctx) {\n  return domToArray(typeof selector === 'string' ?\n    (ctx || document).querySelectorAll(selector) :\n    selector\n  )\n}\n","/**\n * Converts any DOM node/s to a loopable array\n * @param   { HTMLElement|NodeList } els - single html element or a node list\n * @returns { Array } always a loopable object\n */\nexport default function domToArray(els) {\n  // can this object be already looped?\n  if (!Array.isArray(els)) {\n    // is it a node list?\n    if (\n      /^\\[object (HTMLCollection|NodeList|Object)\\]$/\n        .test(Object.prototype.toString.call(els))\n        && typeof els.length === 'number'\n    )\n      return Array.from(els)\n    else\n      // if it's a single node\n      // it will be returned as \"array\" with one single entry\n      return [els]\n  }\n  // this object could be looped out of the box\n  return els\n}","\"use strict\";\n\n/* eslint-env browser */\n\n/*\n  eslint-disable\n  no-console,\n  func-names\n*/\nvar normalizeUrl = require(\"./normalize-url\");\n\nvar srcByModuleId = Object.create(null);\nvar noDocument = typeof document === \"undefined\";\nvar forEach = Array.prototype.forEach;\n\nfunction debounce(fn, time) {\n  var timeout = 0;\n  return function () {\n    var self = this; // eslint-disable-next-line prefer-rest-params\n\n    var args = arguments;\n\n    var functionCall = function functionCall() {\n      return fn.apply(self, args);\n    };\n\n    clearTimeout(timeout);\n    timeout = setTimeout(functionCall, time);\n  };\n}\n\nfunction noop() {}\n\nfunction getCurrentScriptUrl(moduleId) {\n  var src = srcByModuleId[moduleId];\n\n  if (!src) {\n    if (document.currentScript) {\n      src = document.currentScript.src;\n    } else {\n      var scripts = document.getElementsByTagName(\"script\");\n      var lastScriptTag = scripts[scripts.length - 1];\n\n      if (lastScriptTag) {\n        src = lastScriptTag.src;\n      }\n    }\n\n    srcByModuleId[moduleId] = src;\n  }\n\n  return function (fileMap) {\n    if (!src) {\n      return null;\n    }\n\n    var splitResult = src.split(/([^\\\\/]+)\\.js$/);\n    var filename = splitResult && splitResult[1];\n\n    if (!filename) {\n      return [src.replace(\".js\", \".css\")];\n    }\n\n    if (!fileMap) {\n      return [src.replace(\".js\", \".css\")];\n    }\n\n    return fileMap.split(\",\").map(function (mapRule) {\n      var reg = new RegExp(\"\".concat(filename, \"\\\\.js$\"), \"g\");\n      return normalizeUrl(src.replace(reg, \"\".concat(mapRule.replace(/{fileName}/g, filename), \".css\")));\n    });\n  };\n}\n\nfunction updateCss(el, url) {\n  if (!url) {\n    if (!el.href) {\n      return;\n    } // eslint-disable-next-line\n\n\n    url = el.href.split(\"?\")[0];\n  }\n\n  if (!isUrlRequest(url)) {\n    return;\n  }\n\n  if (el.isLoaded === false) {\n    // We seem to be about to replace a css link that hasn't loaded yet.\n    // We're probably changing the same file more than once.\n    return;\n  }\n\n  if (!url || !(url.indexOf(\".css\") > -1)) {\n    return;\n  } // eslint-disable-next-line no-param-reassign\n\n\n  el.visited = true;\n  var newEl = el.cloneNode();\n  newEl.isLoaded = false;\n  newEl.addEventListener(\"load\", function () {\n    if (newEl.isLoaded) {\n      return;\n    }\n\n    newEl.isLoaded = true;\n    el.parentNode.removeChild(el);\n  });\n  newEl.addEventListener(\"error\", function () {\n    if (newEl.isLoaded) {\n      return;\n    }\n\n    newEl.isLoaded = true;\n    el.parentNode.removeChild(el);\n  });\n  newEl.href = \"\".concat(url, \"?\").concat(Date.now());\n\n  if (el.nextSibling) {\n    el.parentNode.insertBefore(newEl, el.nextSibling);\n  } else {\n    el.parentNode.appendChild(newEl);\n  }\n}\n\nfunction getReloadUrl(href, src) {\n  var ret; // eslint-disable-next-line no-param-reassign\n\n  href = normalizeUrl(href, {\n    stripWWW: false\n  }); // eslint-disable-next-line array-callback-return\n\n  src.some(function (url) {\n    if (href.indexOf(src) > -1) {\n      ret = url;\n    }\n  });\n  return ret;\n}\n\nfunction reloadStyle(src) {\n  if (!src) {\n    return false;\n  }\n\n  var elements = document.querySelectorAll(\"link\");\n  var loaded = false;\n  forEach.call(elements, function (el) {\n    if (!el.href) {\n      return;\n    }\n\n    var url = getReloadUrl(el.href, src);\n\n    if (!isUrlRequest(url)) {\n      return;\n    }\n\n    if (el.visited === true) {\n      return;\n    }\n\n    if (url) {\n      updateCss(el, url);\n      loaded = true;\n    }\n  });\n  return loaded;\n}\n\nfunction reloadAll() {\n  var elements = document.querySelectorAll(\"link\");\n  forEach.call(elements, function (el) {\n    if (el.visited === true) {\n      return;\n    }\n\n    updateCss(el);\n  });\n}\n\nfunction isUrlRequest(url) {\n  // An URL is not an request if\n  // It is not http or https\n  if (!/^https?:/i.test(url)) {\n    return false;\n  }\n\n  return true;\n}\n\nmodule.exports = function (moduleId, options) {\n  if (noDocument) {\n    console.log(\"no window.document found, will not HMR CSS\");\n    return noop;\n  }\n\n  var getScriptSrc = getCurrentScriptUrl(moduleId);\n\n  function update() {\n    var src = getScriptSrc(options.filename);\n    var reloaded = reloadStyle(src);\n\n    if (options.locals) {\n      console.log(\"[HMR] Detected local css modules. Reload all css\");\n      reloadAll();\n      return;\n    }\n\n    if (reloaded) {\n      console.log(\"[HMR] css reload %s\", src.join(\" \"));\n    } else {\n      console.log(\"[HMR] Reload all css\");\n      reloadAll();\n    }\n  }\n\n  return debounce(update, 50);\n};","\"use strict\";\n\n/* eslint-disable */\nfunction normalizeUrl(pathComponents) {\n  return pathComponents.reduce(function (accumulator, item) {\n    switch (item) {\n      case \"..\":\n        accumulator.pop();\n        break;\n\n      case \".\":\n        break;\n\n      default:\n        accumulator.push(item);\n    }\n\n    return accumulator;\n  }, []).join(\"/\");\n}\n\nmodule.exports = function (urlString) {\n  urlString = urlString.trim();\n\n  if (/^data:/i.test(urlString)) {\n    return urlString;\n  }\n\n  var protocol = urlString.indexOf(\"//\") !== -1 ? urlString.split(\"//\")[0] + \"//\" : \"\";\n  var components = urlString.replace(new RegExp(protocol, \"i\"), \"\").split(\"/\");\n  var host = components[0].toLowerCase().replace(/\\.$/, \"\");\n  components[0] = \"\";\n  var path = normalizeUrl(components);\n  return protocol + host + path;\n};","// extracted by mini-css-extract-plugin\nexport {};\n    if(module.hot) {\n      // 1632446176229\n      var cssReload = require(\"C:/Users/sleep/software-dev/temp/riotjs-lyric-translation-app/node_modules/mini-css-extract-plugin/dist/hmr/hotModuleReplacement.js\")(module.id, {\"locals\":false});\n      module.hot.dispose(cssReload);\n      module.hot.accept(undefined, cssReload);\n    }\n  ","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","/* Riot v6.0.2, @license MIT */\n/**\n * Convert a string from camel case to dash-case\n * @param   {string} string - probably a component tag name\n * @returns {string} component name normalized\n */\nfunction camelToDashCase(string) {\n  return string.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n}\n/**\n * Convert a string containing dashes to camel case\n * @param   {string} string - input string\n * @returns {string} my-string -> myString\n */\n\nfunction dashToCamelCase(string) {\n  return string.replace(/-(\\w)/g, (_, c) => c.toUpperCase());\n}\n\n/**\n * Get all the element attributes as object\n * @param   {HTMLElement} element - DOM node we want to parse\n * @returns {Object} all the attributes found as a key value pairs\n */\n\nfunction DOMattributesToObject(element) {\n  return Array.from(element.attributes).reduce((acc, attribute) => {\n    acc[dashToCamelCase(attribute.name)] = attribute.value;\n    return acc;\n  }, {});\n}\n/**\n * Move all the child nodes from a source tag to another\n * @param   {HTMLElement} source - source node\n * @param   {HTMLElement} target - target node\n * @returns {undefined} it's a void method \\_()_/\n */\n// Ignore this helper because it's needed only for svg tags\n\nfunction moveChildren(source, target) {\n  if (source.firstChild) {\n    target.appendChild(source.firstChild);\n    moveChildren(source, target);\n  }\n}\n/**\n * Remove the child nodes from any DOM node\n * @param   {HTMLElement} node - target node\n * @returns {undefined}\n */\n\nfunction cleanNode(node) {\n  clearChildren(node.childNodes);\n}\n/**\n * Clear multiple children in a node\n * @param   {HTMLElement[]} children - direct children nodes\n * @returns {undefined}\n */\n\nfunction clearChildren(children) {\n  Array.from(children).forEach(removeChild);\n}\n/**\n * Remove a node\n * @param {HTMLElement}node - node to remove\n * @returns {undefined}\n */\n\nconst removeChild = node => node && node.parentNode && node.parentNode.removeChild(node);\n/**\n * Insert before a node\n * @param {HTMLElement} newNode - node to insert\n * @param {HTMLElement} refNode - ref child\n * @returns {undefined}\n */\n\nconst insertBefore = (newNode, refNode) => refNode && refNode.parentNode && refNode.parentNode.insertBefore(newNode, refNode);\n/**\n * Replace a node\n * @param {HTMLElement} newNode - new node to add to the DOM\n * @param {HTMLElement} replaced - node to replace\n * @returns {undefined}\n */\n\nconst replaceChild = (newNode, replaced) => replaced && replaced.parentNode && replaced.parentNode.replaceChild(newNode, replaced);\n\n// Riot.js constants that can be used accross more modules\nconst COMPONENTS_IMPLEMENTATION_MAP$1 = new Map(),\n      DOM_COMPONENT_INSTANCE_PROPERTY$1 = Symbol('riot-component'),\n      PLUGINS_SET$1 = new Set(),\n      IS_DIRECTIVE = 'is',\n      VALUE_ATTRIBUTE = 'value',\n      MOUNT_METHOD_KEY = 'mount',\n      UPDATE_METHOD_KEY = 'update',\n      UNMOUNT_METHOD_KEY = 'unmount',\n      SHOULD_UPDATE_KEY = 'shouldUpdate',\n      ON_BEFORE_MOUNT_KEY = 'onBeforeMount',\n      ON_MOUNTED_KEY = 'onMounted',\n      ON_BEFORE_UPDATE_KEY = 'onBeforeUpdate',\n      ON_UPDATED_KEY = 'onUpdated',\n      ON_BEFORE_UNMOUNT_KEY = 'onBeforeUnmount',\n      ON_UNMOUNTED_KEY = 'onUnmounted',\n      PROPS_KEY = 'props',\n      STATE_KEY = 'state',\n      SLOTS_KEY = 'slots',\n      ROOT_KEY = 'root',\n      IS_PURE_SYMBOL = Symbol('pure'),\n      IS_COMPONENT_UPDATING = Symbol('is_updating'),\n      PARENT_KEY_SYMBOL = Symbol('parent'),\n      ATTRIBUTES_KEY_SYMBOL = Symbol('attributes'),\n      TEMPLATE_KEY_SYMBOL = Symbol('template');\n\nvar globals = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  COMPONENTS_IMPLEMENTATION_MAP: COMPONENTS_IMPLEMENTATION_MAP$1,\n  DOM_COMPONENT_INSTANCE_PROPERTY: DOM_COMPONENT_INSTANCE_PROPERTY$1,\n  PLUGINS_SET: PLUGINS_SET$1,\n  IS_DIRECTIVE: IS_DIRECTIVE,\n  VALUE_ATTRIBUTE: VALUE_ATTRIBUTE,\n  MOUNT_METHOD_KEY: MOUNT_METHOD_KEY,\n  UPDATE_METHOD_KEY: UPDATE_METHOD_KEY,\n  UNMOUNT_METHOD_KEY: UNMOUNT_METHOD_KEY,\n  SHOULD_UPDATE_KEY: SHOULD_UPDATE_KEY,\n  ON_BEFORE_MOUNT_KEY: ON_BEFORE_MOUNT_KEY,\n  ON_MOUNTED_KEY: ON_MOUNTED_KEY,\n  ON_BEFORE_UPDATE_KEY: ON_BEFORE_UPDATE_KEY,\n  ON_UPDATED_KEY: ON_UPDATED_KEY,\n  ON_BEFORE_UNMOUNT_KEY: ON_BEFORE_UNMOUNT_KEY,\n  ON_UNMOUNTED_KEY: ON_UNMOUNTED_KEY,\n  PROPS_KEY: PROPS_KEY,\n  STATE_KEY: STATE_KEY,\n  SLOTS_KEY: SLOTS_KEY,\n  ROOT_KEY: ROOT_KEY,\n  IS_PURE_SYMBOL: IS_PURE_SYMBOL,\n  IS_COMPONENT_UPDATING: IS_COMPONENT_UPDATING,\n  PARENT_KEY_SYMBOL: PARENT_KEY_SYMBOL,\n  ATTRIBUTES_KEY_SYMBOL: ATTRIBUTES_KEY_SYMBOL,\n  TEMPLATE_KEY_SYMBOL: TEMPLATE_KEY_SYMBOL\n});\n\nconst EACH = 0;\nconst IF = 1;\nconst SIMPLE = 2;\nconst TAG = 3;\nconst SLOT = 4;\nvar bindingTypes = {\n  EACH,\n  IF,\n  SIMPLE,\n  TAG,\n  SLOT\n};\n\nconst ATTRIBUTE = 0;\nconst EVENT = 1;\nconst TEXT = 2;\nconst VALUE = 3;\nvar expressionTypes = {\n  ATTRIBUTE,\n  EVENT,\n  TEXT,\n  VALUE\n};\n\nconst HEAD_SYMBOL = Symbol('head');\nconst TAIL_SYMBOL = Symbol('tail');\n\n/**\n * Create the <template> fragments text nodes\n * @return {Object} {{head: Text, tail: Text}}\n */\n\nfunction createHeadTailPlaceholders() {\n  const head = document.createTextNode('');\n  const tail = document.createTextNode('');\n  head[HEAD_SYMBOL] = true;\n  tail[TAIL_SYMBOL] = true;\n  return {\n    head,\n    tail\n  };\n}\n\n/**\n * Create the template meta object in case of <template> fragments\n * @param   {TemplateChunk} componentTemplate - template chunk object\n * @returns {Object} the meta property that will be passed to the mount function of the TemplateChunk\n */\n\nfunction createTemplateMeta(componentTemplate) {\n  const fragment = componentTemplate.dom.cloneNode(true);\n  const {\n    head,\n    tail\n  } = createHeadTailPlaceholders();\n  return {\n    avoidDOMInjection: true,\n    fragment,\n    head,\n    tail,\n    children: [head, ...Array.from(fragment.childNodes), tail]\n  };\n}\n\n/**\n * Helper function to set an immutable property\n * @param   {Object} source - object where the new property will be set\n * @param   {string} key - object key where the new property will be stored\n * @param   {*} value - value of the new property\n * @param   {Object} options - set the propery overriding the default options\n * @returns {Object} - the original object modified\n */\nfunction defineProperty(source, key, value, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  /* eslint-disable fp/no-mutating-methods */\n  Object.defineProperty(source, key, Object.assign({\n    value,\n    enumerable: false,\n    writable: false,\n    configurable: true\n  }, options));\n  /* eslint-enable fp/no-mutating-methods */\n\n  return source;\n}\n/**\n * Define multiple properties on a target object\n * @param   {Object} source - object where the new properties will be set\n * @param   {Object} properties - object containing as key pair the key + value properties\n * @param   {Object} options - set the propery overriding the default options\n * @returns {Object} the original object modified\n */\n\nfunction defineProperties(source, properties, options) {\n  Object.entries(properties).forEach(_ref => {\n    let [key, value] = _ref;\n    defineProperty(source, key, value, options);\n  });\n  return source;\n}\n/**\n * Define default properties if they don't exist on the source object\n * @param   {Object} source - object that will receive the default properties\n * @param   {Object} defaults - object containing additional optional keys\n * @returns {Object} the original object received enhanced\n */\n\nfunction defineDefaults(source, defaults) {\n  Object.entries(defaults).forEach(_ref2 => {\n    let [key, value] = _ref2;\n    if (!source[key]) source[key] = value;\n  });\n  return source;\n}\n\n/**\n * Get the current <template> fragment children located in between the head and tail comments\n * @param {Comment} head - head comment node\n * @param {Comment} tail - tail comment node\n * @return {Array[]} children list of the nodes found in this template fragment\n */\n\nfunction getFragmentChildren(_ref) {\n  let {\n    head,\n    tail\n  } = _ref;\n  const nodes = walkNodes([head], head.nextSibling, n => n === tail, false);\n  nodes.push(tail);\n  return nodes;\n}\n/**\n * Recursive function to walk all the <template> children nodes\n * @param {Array[]} children - children nodes collection\n * @param {ChildNode} node - current node\n * @param {Function} check - exit function check\n * @param {boolean} isFilterActive - filter flag to skip nodes managed by other bindings\n * @returns {Array[]} children list of the nodes found in this template fragment\n */\n\nfunction walkNodes(children, node, check, isFilterActive) {\n  const {\n    nextSibling\n  } = node; // filter tail and head nodes together with all the nodes in between\n  // this is needed only to fix a really ugly edge case https://github.com/riot/riot/issues/2892\n\n  if (!isFilterActive && !node[HEAD_SYMBOL] && !node[TAIL_SYMBOL]) {\n    children.push(node);\n  }\n\n  if (!nextSibling || check(node)) return children;\n  return walkNodes(children, nextSibling, check, // activate the filters to skip nodes between <template> fragments that will be managed by other bindings\n  isFilterActive && !node[TAIL_SYMBOL] || nextSibling[HEAD_SYMBOL]);\n}\n\n/**\n * Quick type checking\n * @param   {*} element - anything\n * @param   {string} type - type definition\n * @returns {boolean} true if the type corresponds\n */\nfunction checkType(element, type) {\n  return typeof element === type;\n}\n/**\n * Check if an element is part of an svg\n * @param   {HTMLElement}  el - element to check\n * @returns {boolean} true if we are in an svg context\n */\n\nfunction isSvg(el) {\n  const owner = el.ownerSVGElement;\n  return !!owner || owner === null;\n}\n/**\n * Check if an element is a template tag\n * @param   {HTMLElement}  el - element to check\n * @returns {boolean} true if it's a <template>\n */\n\nfunction isTemplate(el) {\n  return el.tagName.toLowerCase() === 'template';\n}\n/**\n * Check that will be passed if its argument is a function\n * @param   {*} value - value to check\n * @returns {boolean} - true if the value is a function\n */\n\nfunction isFunction(value) {\n  return checkType(value, 'function');\n}\n/**\n * Check if a value is a Boolean\n * @param   {*}  value - anything\n * @returns {boolean} true only for the value is a boolean\n */\n\nfunction isBoolean(value) {\n  return checkType(value, 'boolean');\n}\n/**\n * Check if a value is an Object\n * @param   {*}  value - anything\n * @returns {boolean} true only for the value is an object\n */\n\nfunction isObject(value) {\n  return !isNil(value) && value.constructor === Object;\n}\n/**\n * Check if a value is null or undefined\n * @param   {*}  value - anything\n * @returns {boolean} true only for the 'undefined' and 'null' types\n */\n\nfunction isNil(value) {\n  return value === null || value === undefined;\n}\n\n/**\n * ISC License\n *\n * Copyright (c) 2020, Andrea Giammarchi, @WebReflection\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n// fork of https://github.com/WebReflection/udomdiff version 1.1.0\n// due to https://github.com/WebReflection/udomdiff/pull/2\n\n/* eslint-disable */\n\n/**\n * @param {Node[]} a The list of current/live children\n * @param {Node[]} b The list of future children\n * @param {(entry: Node, action: number) => Node} get\n * The callback invoked per each entry related DOM operation.\n * @param {Node} [before] The optional node used as anchor to insert before.\n * @returns {Node[]} The same list of future children.\n */\n\nvar udomdiff = ((a, b, get, before) => {\n  const bLength = b.length;\n  let aEnd = a.length;\n  let bEnd = bLength;\n  let aStart = 0;\n  let bStart = 0;\n  let map = null;\n\n  while (aStart < aEnd || bStart < bEnd) {\n    // append head, tail, or nodes in between: fast path\n    if (aEnd === aStart) {\n      // we could be in a situation where the rest of nodes that\n      // need to be added are not at the end, and in such case\n      // the node to `insertBefore`, if the index is more than 0\n      // must be retrieved, otherwise it's gonna be the first item.\n      const node = bEnd < bLength ? bStart ? get(b[bStart - 1], -0).nextSibling : get(b[bEnd - bStart], 0) : before;\n\n      while (bStart < bEnd) insertBefore(get(b[bStart++], 1), node);\n    } // remove head or tail: fast path\n    else if (bEnd === bStart) {\n      while (aStart < aEnd) {\n        // remove the node only if it's unknown or not live\n        if (!map || !map.has(a[aStart])) removeChild(get(a[aStart], -1));\n        aStart++;\n      }\n    } // same node: fast path\n    else if (a[aStart] === b[bStart]) {\n      aStart++;\n      bStart++;\n    } // same tail: fast path\n    else if (a[aEnd - 1] === b[bEnd - 1]) {\n      aEnd--;\n      bEnd--;\n    } // The once here single last swap \"fast path\" has been removed in v1.1.0\n    // https://github.com/WebReflection/udomdiff/blob/single-final-swap/esm/index.js#L69-L85\n    // reverse swap: also fast path\n    else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {\n      // this is a \"shrink\" operation that could happen in these cases:\n      // [1, 2, 3, 4, 5]\n      // [1, 4, 3, 2, 5]\n      // or asymmetric too\n      // [1, 2, 3, 4, 5]\n      // [1, 2, 3, 5, 6, 4]\n      const node = get(a[--aEnd], -1).nextSibling;\n      insertBefore(get(b[bStart++], 1), get(a[aStart++], -1).nextSibling);\n      insertBefore(get(b[--bEnd], 1), node); // mark the future index as identical (yeah, it's dirty, but cheap )\n      // The main reason to do this, is that when a[aEnd] will be reached,\n      // the loop will likely be on the fast path, as identical to b[bEnd].\n      // In the best case scenario, the next loop will skip the tail,\n      // but in the worst one, this node will be considered as already\n      // processed, bailing out pretty quickly from the map index check\n\n      a[aEnd] = b[bEnd];\n    } // map based fallback, \"slow\" path\n    else {\n      // the map requires an O(bEnd - bStart) operation once\n      // to store all future nodes indexes for later purposes.\n      // In the worst case scenario, this is a full O(N) cost,\n      // and such scenario happens at least when all nodes are different,\n      // but also if both first and last items of the lists are different\n      if (!map) {\n        map = new Map();\n        let i = bStart;\n\n        while (i < bEnd) map.set(b[i], i++);\n      } // if it's a future node, hence it needs some handling\n\n\n      if (map.has(a[aStart])) {\n        // grab the index of such node, 'cause it might have been processed\n        const index = map.get(a[aStart]); // if it's not already processed, look on demand for the next LCS\n\n        if (bStart < index && index < bEnd) {\n          let i = aStart; // counts the amount of nodes that are the same in the future\n\n          let sequence = 1;\n\n          while (++i < aEnd && i < bEnd && map.get(a[i]) === index + sequence) sequence++; // effort decision here: if the sequence is longer than replaces\n          // needed to reach such sequence, which would brings again this loop\n          // to the fast path, prepend the difference before a sequence,\n          // and move only the future list index forward, so that aStart\n          // and bStart will be aligned again, hence on the fast path.\n          // An example considering aStart and bStart are both 0:\n          // a: [1, 2, 3, 4]\n          // b: [7, 1, 2, 3, 6]\n          // this would place 7 before 1 and, from that time on, 1, 2, and 3\n          // will be processed at zero cost\n\n\n          if (sequence > index - bStart) {\n            const node = get(a[aStart], 0);\n\n            while (bStart < index) insertBefore(get(b[bStart++], 1), node);\n          } // if the effort wasn't good enough, fallback to a replace,\n          // moving both source and target indexes forward, hoping that some\n          // similar node will be found later on, to go back to the fast path\n          else {\n            replaceChild(get(b[bStart++], 1), get(a[aStart++], -1));\n          }\n        } // otherwise move the source forward, 'cause there's nothing to do\n        else aStart++;\n      } // this node has no meaning in the future list, so it's more than safe\n      // to remove it, and check the next live node out instead, meaning\n      // that only the live list index should be forwarded\n      else removeChild(get(a[aStart++], -1));\n    }\n  }\n\n  return b;\n});\n\nconst UNMOUNT_SCOPE = Symbol('unmount');\nconst EachBinding = {\n  // dynamic binding properties\n  // childrenMap: null,\n  // node: null,\n  // root: null,\n  // condition: null,\n  // evaluate: null,\n  // template: null,\n  // isTemplateTag: false,\n  nodes: [],\n\n  // getKey: null,\n  // indexName: null,\n  // itemName: null,\n  // afterPlaceholder: null,\n  // placeholder: null,\n  // API methods\n  mount(scope, parentScope) {\n    return this.update(scope, parentScope);\n  },\n\n  update(scope, parentScope) {\n    const {\n      placeholder,\n      nodes,\n      childrenMap\n    } = this;\n    const collection = scope === UNMOUNT_SCOPE ? null : this.evaluate(scope);\n    const items = collection ? Array.from(collection) : []; // prepare the diffing\n\n    const {\n      newChildrenMap,\n      batches,\n      futureNodes\n    } = createPatch(items, scope, parentScope, this); // patch the DOM only if there are new nodes\n\n    udomdiff(nodes, futureNodes, patch(Array.from(childrenMap.values()), parentScope), placeholder); // trigger the mounts and the updates\n\n    batches.forEach(fn => fn()); // update the children map\n\n    this.childrenMap = newChildrenMap;\n    this.nodes = futureNodes; // make sure that the loop edge nodes are marked\n\n    markEdgeNodes(this.nodes);\n    return this;\n  },\n\n  unmount(scope, parentScope) {\n    this.update(UNMOUNT_SCOPE, parentScope);\n    return this;\n  }\n\n};\n/**\n * Patch the DOM while diffing\n * @param   {any[]} redundant - list of all the children (template, nodes, context) added via each\n * @param   {*} parentScope - scope of the parent template\n * @returns {Function} patch function used by domdiff\n */\n\nfunction patch(redundant, parentScope) {\n  return (item, info) => {\n    if (info < 0) {\n      // get the last element added to the childrenMap saved previously\n      const element = redundant[redundant.length - 1];\n\n      if (element) {\n        // get the nodes and the template in stored in the last child of the childrenMap\n        const {\n          template,\n          nodes,\n          context\n        } = element; // remove the last node (notice <template> tags might have more children nodes)\n\n        nodes.pop(); // notice that we pass null as last argument because\n        // the root node and its children will be removed by domdiff\n\n        if (!nodes.length) {\n          // we have cleared all the children nodes and we can unmount this template\n          redundant.pop();\n          template.unmount(context, parentScope, null);\n        }\n      }\n    }\n\n    return item;\n  };\n}\n/**\n * Check whether a template must be filtered from a loop\n * @param   {Function} condition - filter function\n * @param   {Object} context - argument passed to the filter function\n * @returns {boolean} true if this item should be skipped\n */\n\n\nfunction mustFilterItem(condition, context) {\n  return condition ? !condition(context) : false;\n}\n/**\n * Extend the scope of the looped template\n * @param   {Object} scope - current template scope\n * @param   {Object} options - options\n * @param   {string} options.itemName - key to identify the looped item in the new context\n * @param   {string} options.indexName - key to identify the index of the looped item\n * @param   {number} options.index - current index\n * @param   {*} options.item - collection item looped\n * @returns {Object} enhanced scope object\n */\n\n\nfunction extendScope(scope, _ref) {\n  let {\n    itemName,\n    indexName,\n    index,\n    item\n  } = _ref;\n  defineProperty(scope, itemName, item);\n  if (indexName) defineProperty(scope, indexName, index);\n  return scope;\n}\n/**\n * Mark the first and last nodes in order to ignore them in case we need to retrieve the <template> fragment nodes\n * @param {Array[]} nodes - each binding nodes list\n * @returns {undefined} void function\n */\n\n\nfunction markEdgeNodes(nodes) {\n  const first = nodes[0];\n  const last = nodes[nodes.length - 1];\n  if (first) first[HEAD_SYMBOL] = true;\n  if (last) last[TAIL_SYMBOL] = true;\n}\n/**\n * Loop the current template items\n * @param   {Array} items - expression collection value\n * @param   {*} scope - template scope\n * @param   {*} parentScope - scope of the parent template\n * @param   {EachBinding} binding - each binding object instance\n * @returns {Object} data\n * @returns {Map} data.newChildrenMap - a Map containing the new children template structure\n * @returns {Array} data.batches - array containing the template lifecycle functions to trigger\n * @returns {Array} data.futureNodes - array containing the nodes we need to diff\n */\n\n\nfunction createPatch(items, scope, parentScope, binding) {\n  const {\n    condition,\n    template,\n    childrenMap,\n    itemName,\n    getKey,\n    indexName,\n    root,\n    isTemplateTag\n  } = binding;\n  const newChildrenMap = new Map();\n  const batches = [];\n  const futureNodes = [];\n  items.forEach((item, index) => {\n    const context = extendScope(Object.create(scope), {\n      itemName,\n      indexName,\n      index,\n      item\n    });\n    const key = getKey ? getKey(context) : index;\n    const oldItem = childrenMap.get(key);\n    const nodes = [];\n\n    if (mustFilterItem(condition, context)) {\n      return;\n    }\n\n    const mustMount = !oldItem;\n    const componentTemplate = oldItem ? oldItem.template : template.clone();\n    const el = componentTemplate.el || root.cloneNode();\n    const meta = isTemplateTag && mustMount ? createTemplateMeta(componentTemplate) : componentTemplate.meta;\n\n    if (mustMount) {\n      batches.push(() => componentTemplate.mount(el, context, parentScope, meta));\n    } else {\n      batches.push(() => componentTemplate.update(context, parentScope));\n    } // create the collection of nodes to update or to add\n    // in case of template tags we need to add all its children nodes\n\n\n    if (isTemplateTag) {\n      nodes.push(...(mustMount ? meta.children : getFragmentChildren(meta)));\n    } else {\n      nodes.push(el);\n    } // delete the old item from the children map\n\n\n    childrenMap.delete(key);\n    futureNodes.push(...nodes); // update the children map\n\n    newChildrenMap.set(key, {\n      nodes,\n      template: componentTemplate,\n      context,\n      index\n    });\n  });\n  return {\n    newChildrenMap,\n    batches,\n    futureNodes\n  };\n}\n\nfunction create$6(node, _ref2) {\n  let {\n    evaluate,\n    condition,\n    itemName,\n    indexName,\n    getKey,\n    template\n  } = _ref2;\n  const placeholder = document.createTextNode('');\n  const root = node.cloneNode();\n  insertBefore(placeholder, node);\n  removeChild(node);\n  return Object.assign({}, EachBinding, {\n    childrenMap: new Map(),\n    node,\n    root,\n    condition,\n    evaluate,\n    isTemplateTag: isTemplate(root),\n    template: template.createDOM(node),\n    getKey,\n    indexName,\n    itemName,\n    placeholder\n  });\n}\n\n/**\n * Binding responsible for the `if` directive\n */\n\nconst IfBinding = {\n  // dynamic binding properties\n  // node: null,\n  // evaluate: null,\n  // isTemplateTag: false,\n  // placeholder: null,\n  // template: null,\n  // API methods\n  mount(scope, parentScope) {\n    return this.update(scope, parentScope);\n  },\n\n  update(scope, parentScope) {\n    const value = !!this.evaluate(scope);\n    const mustMount = !this.value && value;\n    const mustUnmount = this.value && !value;\n\n    const mount = () => {\n      const pristine = this.node.cloneNode();\n      insertBefore(pristine, this.placeholder);\n      this.template = this.template.clone();\n      this.template.mount(pristine, scope, parentScope);\n    };\n\n    switch (true) {\n      case mustMount:\n        mount();\n        break;\n\n      case mustUnmount:\n        this.unmount(scope);\n        break;\n\n      default:\n        if (value) this.template.update(scope, parentScope);\n    }\n\n    this.value = value;\n    return this;\n  },\n\n  unmount(scope, parentScope) {\n    this.template.unmount(scope, parentScope, true);\n    return this;\n  }\n\n};\nfunction create$5(node, _ref) {\n  let {\n    evaluate,\n    template\n  } = _ref;\n  const placeholder = document.createTextNode('');\n  insertBefore(placeholder, node);\n  removeChild(node);\n  return Object.assign({}, IfBinding, {\n    node,\n    evaluate,\n    placeholder,\n    template: template.createDOM(node)\n  });\n}\n\n/**\n * Throw an error with a descriptive message\n * @param   { string } message - error message\n * @returns { undefined } hoppla.. at this point the program should stop working\n */\n\nfunction panic(message) {\n  throw new Error(message);\n}\n/**\n * Returns the memoized (cached) function.\n * // borrowed from https://www.30secondsofcode.org/js/s/memoize\n * @param {Function} fn - function to memoize\n * @returns {Function} memoize function\n */\n\nfunction memoize(fn) {\n  const cache = new Map();\n\n  const cached = val => {\n    return cache.has(val) ? cache.get(val) : cache.set(val, fn.call(this, val)) && cache.get(val);\n  };\n\n  cached.cache = cache;\n  return cached;\n}\n/**\n * Evaluate a list of attribute expressions\n * @param   {Array} attributes - attribute expressions generated by the riot compiler\n * @returns {Object} key value pairs with the result of the computation\n */\n\nfunction evaluateAttributeExpressions(attributes) {\n  return attributes.reduce((acc, attribute) => {\n    const {\n      value,\n      type\n    } = attribute;\n\n    switch (true) {\n      // spread attribute\n      case !attribute.name && type === ATTRIBUTE:\n        return Object.assign({}, acc, value);\n      // value attribute\n\n      case type === VALUE:\n        acc.value = attribute.value;\n        break;\n      // normal attributes\n\n      default:\n        acc[dashToCamelCase(attribute.name)] = attribute.value;\n    }\n\n    return acc;\n  }, {});\n}\n\nconst ElementProto = typeof Element === 'undefined' ? {} : Element.prototype;\nconst isNativeHtmlProperty = memoize(name => ElementProto.hasOwnProperty(name)); // eslint-disable-line\n\n/**\n * Add all the attributes provided\n * @param   {HTMLElement} node - target node\n * @param   {Object} attributes - object containing the attributes names and values\n * @returns {undefined} sorry it's a void function :(\n */\n\nfunction setAllAttributes(node, attributes) {\n  Object.entries(attributes).forEach(_ref => {\n    let [name, value] = _ref;\n    return attributeExpression(node, {\n      name\n    }, value);\n  });\n}\n/**\n * Remove all the attributes provided\n * @param   {HTMLElement} node - target node\n * @param   {Object} newAttributes - object containing all the new attribute names\n * @param   {Object} oldAttributes - object containing all the old attribute names\n * @returns {undefined} sorry it's a void function :(\n */\n\n\nfunction removeAllAttributes(node, newAttributes, oldAttributes) {\n  const newKeys = newAttributes ? Object.keys(newAttributes) : [];\n  Object.keys(oldAttributes).filter(name => !newKeys.includes(name)).forEach(attribute => node.removeAttribute(attribute));\n}\n/**\n * Check whether the attribute value can be rendered\n * @param {*} value - expression value\n * @returns {boolean} true if we can render this attribute value\n */\n\n\nfunction canRenderAttribute(value) {\n  return value === true || ['string', 'number'].includes(typeof value);\n}\n/**\n * Check whether the attribute should be removed\n * @param {*} value - expression value\n * @returns {boolean} boolean - true if the attribute can be removed}\n */\n\n\nfunction shouldRemoveAttribute(value) {\n  return !value && value !== 0;\n}\n/**\n * This methods handles the DOM attributes updates\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {string} expression.name - attribute name\n * @param   {*} value - new expression value\n * @param   {*} oldValue - the old expression cached value\n * @returns {undefined}\n */\n\n\nfunction attributeExpression(node, _ref2, value, oldValue) {\n  let {\n    name\n  } = _ref2;\n\n  // is it a spread operator? {...attributes}\n  if (!name) {\n    if (oldValue) {\n      // remove all the old attributes\n      removeAllAttributes(node, value, oldValue);\n    } // is the value still truthy?\n\n\n    if (value) {\n      setAllAttributes(node, value);\n    }\n\n    return;\n  } // handle boolean attributes\n\n\n  if (!isNativeHtmlProperty(name) && (isBoolean(value) || isObject(value) || isFunction(value))) {\n    node[name] = value;\n  }\n\n  if (shouldRemoveAttribute(value)) {\n    node.removeAttribute(name);\n  } else if (canRenderAttribute(value)) {\n    node.setAttribute(name, normalizeValue(name, value));\n  }\n}\n/**\n * Get the value as string\n * @param   {string} name - attribute name\n * @param   {*} value - user input value\n * @returns {string} input value as string\n */\n\nfunction normalizeValue(name, value) {\n  // be sure that expressions like selected={ true } will be always rendered as selected='selected'\n  return value === true ? name : value;\n}\n\nconst RE_EVENTS_PREFIX = /^on/;\n\nconst getCallbackAndOptions = value => Array.isArray(value) ? value : [value, false]; // see also https://medium.com/@WebReflection/dom-handleevent-a-cross-platform-standard-since-year-2000-5bf17287fd38\n\n\nconst EventListener = {\n  handleEvent(event) {\n    this[event.type](event);\n  }\n\n};\nconst ListenersWeakMap = new WeakMap();\n\nconst createListener = node => {\n  const listener = Object.create(EventListener);\n  ListenersWeakMap.set(node, listener);\n  return listener;\n};\n/**\n * Set a new event listener\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {string} expression.name - event name\n * @param   {*} value - new expression value\n * @returns {value} the callback just received\n */\n\n\nfunction eventExpression(node, _ref, value) {\n  let {\n    name\n  } = _ref;\n  const normalizedEventName = name.replace(RE_EVENTS_PREFIX, '');\n  const eventListener = ListenersWeakMap.get(node) || createListener(node);\n  const [callback, options] = getCallbackAndOptions(value);\n  const handler = eventListener[normalizedEventName];\n  const mustRemoveEvent = handler && !callback;\n  const mustAddEvent = callback && !handler;\n\n  if (mustRemoveEvent) {\n    node.removeEventListener(normalizedEventName, eventListener);\n  }\n\n  if (mustAddEvent) {\n    node.addEventListener(normalizedEventName, eventListener, options);\n  }\n\n  eventListener[normalizedEventName] = callback;\n}\n\n/**\n * Normalize the user value in order to render a empty string in case of falsy values\n * @param   {*} value - user input value\n * @returns {string} hopefully a string\n */\n\nfunction normalizeStringValue(value) {\n  return isNil(value) ? '' : value;\n}\n\n/**\n * Get the the target text node to update or create one from of a comment node\n * @param   {HTMLElement} node - any html element containing childNodes\n * @param   {number} childNodeIndex - index of the text node in the childNodes list\n * @returns {Text} the text node to update\n */\n\nconst getTextNode = (node, childNodeIndex) => {\n  const target = node.childNodes[childNodeIndex];\n\n  if (target.nodeType === Node.COMMENT_NODE) {\n    const textNode = document.createTextNode('');\n    node.replaceChild(textNode, target);\n    return textNode;\n  }\n\n  return target;\n};\n/**\n * This methods handles a simple text expression update\n * @param   {HTMLElement} node - target node\n * @param   {Object} data - expression object\n * @param   {*} value - new expression value\n * @returns {undefined}\n */\n\nfunction textExpression(node, data, value) {\n  node.data = normalizeStringValue(value);\n}\n\n/**\n * This methods handles the input fileds value updates\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {*} value - new expression value\n * @returns {undefined}\n */\n\nfunction valueExpression(node, expression, value) {\n  node.value = normalizeStringValue(value);\n}\n\nvar expressions = {\n  [ATTRIBUTE]: attributeExpression,\n  [EVENT]: eventExpression,\n  [TEXT]: textExpression,\n  [VALUE]: valueExpression\n};\n\nconst Expression = {\n  // Static props\n  // node: null,\n  // value: null,\n  // API methods\n\n  /**\n   * Mount the expression evaluating its initial value\n   * @param   {*} scope - argument passed to the expression to evaluate its current values\n   * @returns {Expression} self\n   */\n  mount(scope) {\n    // hopefully a pure function\n    this.value = this.evaluate(scope); // IO() DOM updates\n\n    apply(this, this.value);\n    return this;\n  },\n\n  /**\n   * Update the expression if its value changed\n   * @param   {*} scope - argument passed to the expression to evaluate its current values\n   * @returns {Expression} self\n   */\n  update(scope) {\n    // pure function\n    const value = this.evaluate(scope);\n\n    if (this.value !== value) {\n      // IO() DOM updates\n      apply(this, value);\n      this.value = value;\n    }\n\n    return this;\n  },\n\n  /**\n   * Expression teardown method\n   * @returns {Expression} self\n   */\n  unmount() {\n    // unmount only the event handling expressions\n    if (this.type === EVENT) apply(this, null);\n    return this;\n  }\n\n};\n/**\n * IO() function to handle the DOM updates\n * @param {Expression} expression - expression object\n * @param {*} value - current expression value\n * @returns {undefined}\n */\n\nfunction apply(expression, value) {\n  return expressions[expression.type](expression.node, expression, value, expression.value);\n}\n\nfunction create$4(node, data) {\n  return Object.assign({}, Expression, data, {\n    node: data.type === TEXT ? getTextNode(node, data.childNodeIndex) : node\n  });\n}\n\n/**\n * Create a flat object having as keys a list of methods that if dispatched will propagate\n * on the whole collection\n * @param   {Array} collection - collection to iterate\n * @param   {Array<string>} methods - methods to execute on each item of the collection\n * @param   {*} context - context returned by the new methods created\n * @returns {Object} a new object to simplify the the nested methods dispatching\n */\nfunction flattenCollectionMethods(collection, methods, context) {\n  return methods.reduce((acc, method) => {\n    return Object.assign({}, acc, {\n      [method]: scope => {\n        return collection.map(item => item[method](scope)) && context;\n      }\n    });\n  }, {});\n}\n\nfunction create$3(node, _ref) {\n  let {\n    expressions\n  } = _ref;\n  return Object.assign({}, flattenCollectionMethods(expressions.map(expression => create$4(node, expression)), ['mount', 'update', 'unmount']));\n}\n\nfunction extendParentScope(attributes, scope, parentScope) {\n  if (!attributes || !attributes.length) return parentScope;\n  const expressions = attributes.map(attr => Object.assign({}, attr, {\n    value: attr.evaluate(scope)\n  }));\n  return Object.assign(Object.create(parentScope || null), evaluateAttributeExpressions(expressions));\n} // this function is only meant to fix an edge case\n// https://github.com/riot/riot/issues/2842\n\n\nconst getRealParent = (scope, parentScope) => scope[PARENT_KEY_SYMBOL] || parentScope;\n\nconst SlotBinding = {\n  // dynamic binding properties\n  // node: null,\n  // name: null,\n  attributes: [],\n\n  // template: null,\n  getTemplateScope(scope, parentScope) {\n    return extendParentScope(this.attributes, scope, parentScope);\n  },\n\n  // API methods\n  mount(scope, parentScope) {\n    const templateData = scope.slots ? scope.slots.find(_ref => {\n      let {\n        id\n      } = _ref;\n      return id === this.name;\n    }) : false;\n    const {\n      parentNode\n    } = this.node;\n    const realParent = getRealParent(scope, parentScope);\n    this.template = templateData && create(templateData.html, templateData.bindings).createDOM(parentNode);\n\n    if (this.template) {\n      cleanNode(this.node);\n      this.template.mount(this.node, this.getTemplateScope(scope, realParent), realParent);\n      this.template.children = Array.from(this.node.childNodes);\n    }\n\n    moveSlotInnerContent(this.node);\n    removeChild(this.node);\n    return this;\n  },\n\n  update(scope, parentScope) {\n    if (this.template) {\n      const realParent = getRealParent(scope, parentScope);\n      this.template.update(this.getTemplateScope(scope, realParent), realParent);\n    }\n\n    return this;\n  },\n\n  unmount(scope, parentScope, mustRemoveRoot) {\n    if (this.template) {\n      this.template.unmount(this.getTemplateScope(scope, parentScope), null, mustRemoveRoot);\n    }\n\n    return this;\n  }\n\n};\n/**\n * Move the inner content of the slots outside of them\n * @param   {HTMLElement} slot - slot node\n * @returns {undefined} it's a void method \\_()_/\n */\n\nfunction moveSlotInnerContent(slot) {\n  const child = slot && slot.firstChild;\n  if (!child) return;\n  insertBefore(child, slot);\n  moveSlotInnerContent(slot);\n}\n/**\n * Create a single slot binding\n * @param   {HTMLElement} node - slot node\n * @param   {string} name - slot id\n * @param   {AttributeExpressionData[]} attributes - slot attributes\n * @returns {Object} Slot binding object\n */\n\n\nfunction createSlot(node, _ref2) {\n  let {\n    name,\n    attributes\n  } = _ref2;\n  return Object.assign({}, SlotBinding, {\n    attributes,\n    node,\n    name\n  });\n}\n\n/**\n * Create a new tag object if it was registered before, otherwise fallback to the simple\n * template chunk\n * @param   {Function} component - component factory function\n * @param   {Array<Object>} slots - array containing the slots markup\n * @param   {Array} attributes - dynamic attributes that will be received by the tag element\n * @returns {TagImplementation|TemplateChunk} a tag implementation or a template chunk as fallback\n */\n\nfunction getTag(component, slots, attributes) {\n  if (slots === void 0) {\n    slots = [];\n  }\n\n  if (attributes === void 0) {\n    attributes = [];\n  }\n\n  // if this tag was registered before we will return its implementation\n  if (component) {\n    return component({\n      slots,\n      attributes\n    });\n  } // otherwise we return a template chunk\n\n\n  return create(slotsToMarkup(slots), [...slotBindings(slots), {\n    // the attributes should be registered as binding\n    // if we fallback to a normal template chunk\n    expressions: attributes.map(attr => {\n      return Object.assign({\n        type: ATTRIBUTE\n      }, attr);\n    })\n  }]);\n}\n/**\n * Merge all the slots bindings into a single array\n * @param   {Array<Object>} slots - slots collection\n * @returns {Array<Bindings>} flatten bindings array\n */\n\n\nfunction slotBindings(slots) {\n  return slots.reduce((acc, _ref) => {\n    let {\n      bindings\n    } = _ref;\n    return acc.concat(bindings);\n  }, []);\n}\n/**\n * Merge all the slots together in a single markup string\n * @param   {Array<Object>} slots - slots collection\n * @returns {string} markup of all the slots in a single string\n */\n\n\nfunction slotsToMarkup(slots) {\n  return slots.reduce((acc, slot) => {\n    return acc + slot.html;\n  }, '');\n}\n\nconst TagBinding = {\n  // dynamic binding properties\n  // node: null,\n  // evaluate: null,\n  // name: null,\n  // slots: null,\n  // tag: null,\n  // attributes: null,\n  // getComponent: null,\n  mount(scope) {\n    return this.update(scope);\n  },\n\n  update(scope, parentScope) {\n    const name = this.evaluate(scope); // simple update\n\n    if (name && name === this.name) {\n      this.tag.update(scope);\n    } else {\n      // unmount the old tag if it exists\n      this.unmount(scope, parentScope, true); // mount the new tag\n\n      this.name = name;\n      this.tag = getTag(this.getComponent(name), this.slots, this.attributes);\n      this.tag.mount(this.node, scope);\n    }\n\n    return this;\n  },\n\n  unmount(scope, parentScope, keepRootTag) {\n    if (this.tag) {\n      // keep the root tag\n      this.tag.unmount(keepRootTag);\n    }\n\n    return this;\n  }\n\n};\nfunction create$2(node, _ref2) {\n  let {\n    evaluate,\n    getComponent,\n    slots,\n    attributes\n  } = _ref2;\n  return Object.assign({}, TagBinding, {\n    node,\n    evaluate,\n    slots,\n    attributes,\n    getComponent\n  });\n}\n\nvar bindings = {\n  [IF]: create$5,\n  [SIMPLE]: create$3,\n  [EACH]: create$6,\n  [TAG]: create$2,\n  [SLOT]: createSlot\n};\n\n/**\n * Text expressions in a template tag will get childNodeIndex value normalized\n * depending on the position of the <template> tag offset\n * @param   {Expression[]} expressions - riot expressions array\n * @param   {number} textExpressionsOffset - offset of the <template> tag\n * @returns {Expression[]} expressions containing the text expressions normalized\n */\n\nfunction fixTextExpressionsOffset(expressions, textExpressionsOffset) {\n  return expressions.map(e => e.type === TEXT ? Object.assign({}, e, {\n    childNodeIndex: e.childNodeIndex + textExpressionsOffset\n  }) : e);\n}\n/**\n * Bind a new expression object to a DOM node\n * @param   {HTMLElement} root - DOM node where to bind the expression\n * @param   {TagBindingData} binding - binding data\n * @param   {number|null} templateTagOffset - if it's defined we need to fix the text expressions childNodeIndex offset\n * @returns {Binding} Binding object\n */\n\n\nfunction create$1(root, binding, templateTagOffset) {\n  const {\n    selector,\n    type,\n    redundantAttribute,\n    expressions\n  } = binding; // find the node to apply the bindings\n\n  const node = selector ? root.querySelector(selector) : root; // remove eventually additional attributes created only to select this node\n\n  if (redundantAttribute) node.removeAttribute(redundantAttribute);\n  const bindingExpressions = expressions || []; // init the binding\n\n  return (bindings[type] || bindings[SIMPLE])(node, Object.assign({}, binding, {\n    expressions: templateTagOffset && !selector ? fixTextExpressionsOffset(bindingExpressions, templateTagOffset) : bindingExpressions\n  }));\n}\n\nfunction createHTMLTree(html, root) {\n  const template = isTemplate(root) ? root : document.createElement('template');\n  template.innerHTML = html;\n  return template.content;\n} // for svg nodes we need a bit more work\n\n\nfunction createSVGTree(html, container) {\n  // create the SVGNode\n  const svgNode = container.ownerDocument.importNode(new window.DOMParser().parseFromString(`<svg xmlns=\"http://www.w3.org/2000/svg\">${html}</svg>`, 'application/xml').documentElement, true);\n  return svgNode;\n}\n/**\n * Create the DOM that will be injected\n * @param {Object} root - DOM node to find out the context where the fragment will be created\n * @param   {string} html - DOM to create as string\n * @returns {HTMLDocumentFragment|HTMLElement} a new html fragment\n */\n\n\nfunction createDOMTree(root, html) {\n  if (isSvg(root)) return createSVGTree(html, root);\n  return createHTMLTree(html, root);\n}\n\n/**\n * Inject the DOM tree into a target node\n * @param   {HTMLElement} el - target element\n * @param   {DocumentFragment|SVGElement} dom - dom tree to inject\n * @returns {undefined}\n */\n\nfunction injectDOM(el, dom) {\n  switch (true) {\n    case isSvg(el):\n      moveChildren(dom, el);\n      break;\n\n    case isTemplate(el):\n      el.parentNode.replaceChild(dom, el);\n      break;\n\n    default:\n      el.appendChild(dom);\n  }\n}\n\n/**\n * Create the Template DOM skeleton\n * @param   {HTMLElement} el - root node where the DOM will be injected\n * @param   {string|HTMLElement} html - HTML markup or HTMLElement that will be injected into the root node\n * @returns {?DocumentFragment} fragment that will be injected into the root node\n */\n\nfunction createTemplateDOM(el, html) {\n  return html && (typeof html === 'string' ? createDOMTree(el, html) : html);\n}\n/**\n * Get the offset of the <template> tag\n * @param {HTMLElement} parentNode - template tag parent node\n * @param {HTMLElement} el - the template tag we want to render\n * @param   {Object} meta - meta properties needed to handle the <template> tags in loops\n * @returns {number} offset of the <template> tag calculated from its siblings DOM nodes\n */\n\n\nfunction getTemplateTagOffset(parentNode, el, meta) {\n  const siblings = Array.from(parentNode.childNodes);\n  return Math.max(siblings.indexOf(el), siblings.indexOf(meta.head) + 1, 0);\n}\n/**\n * Template Chunk model\n * @type {Object}\n */\n\n\nconst TemplateChunk = Object.freeze({\n  // Static props\n  // bindings: null,\n  // bindingsData: null,\n  // html: null,\n  // isTemplateTag: false,\n  // fragment: null,\n  // children: null,\n  // dom: null,\n  // el: null,\n\n  /**\n   * Create the template DOM structure that will be cloned on each mount\n   * @param   {HTMLElement} el - the root node\n   * @returns {TemplateChunk} self\n   */\n  createDOM(el) {\n    // make sure that the DOM gets created before cloning the template\n    this.dom = this.dom || createTemplateDOM(el, this.html) || document.createDocumentFragment();\n    return this;\n  },\n\n  // API methods\n\n  /**\n   * Attach the template to a DOM node\n   * @param   {HTMLElement} el - target DOM node\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @param   {Object} meta - meta properties needed to handle the <template> tags in loops\n   * @returns {TemplateChunk} self\n   */\n  mount(el, scope, parentScope, meta) {\n    if (meta === void 0) {\n      meta = {};\n    }\n\n    if (!el) throw new Error('Please provide DOM node to mount properly your template');\n    if (this.el) this.unmount(scope); // <template> tags require a bit more work\n    // the template fragment might be already created via meta outside of this call\n\n    const {\n      fragment,\n      children,\n      avoidDOMInjection\n    } = meta; // <template> bindings of course can not have a root element\n    // so we check the parent node to set the query selector bindings\n\n    const {\n      parentNode\n    } = children ? children[0] : el;\n    const isTemplateTag = isTemplate(el);\n    const templateTagOffset = isTemplateTag ? getTemplateTagOffset(parentNode, el, meta) : null; // create the DOM if it wasn't created before\n\n    this.createDOM(el); // create the DOM of this template cloning the original DOM structure stored in this instance\n    // notice that if a documentFragment was passed (via meta) we will use it instead\n\n    const cloneNode = fragment || this.dom.cloneNode(true); // store root node\n    // notice that for template tags the root note will be the parent tag\n\n    this.el = isTemplateTag ? parentNode : el; // create the children array only for the <template> fragments\n\n    this.children = isTemplateTag ? children || Array.from(cloneNode.childNodes) : null; // inject the DOM into the el only if a fragment is available\n\n    if (!avoidDOMInjection && cloneNode) injectDOM(el, cloneNode); // create the bindings\n\n    this.bindings = this.bindingsData.map(binding => create$1(this.el, binding, templateTagOffset));\n    this.bindings.forEach(b => b.mount(scope, parentScope)); // store the template meta properties\n\n    this.meta = meta;\n    return this;\n  },\n\n  /**\n   * Update the template with fresh data\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @returns {TemplateChunk} self\n   */\n  update(scope, parentScope) {\n    this.bindings.forEach(b => b.update(scope, parentScope));\n    return this;\n  },\n\n  /**\n   * Remove the template from the node where it was initially mounted\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @param   {boolean|null} mustRemoveRoot - if true remove the root element,\n   * if false or undefined clean the root tag content, if null don't touch the DOM\n   * @returns {TemplateChunk} self\n   */\n  unmount(scope, parentScope, mustRemoveRoot) {\n    if (mustRemoveRoot === void 0) {\n      mustRemoveRoot = false;\n    }\n\n    const el = this.el;\n\n    if (!el) {\n      return this;\n    }\n\n    this.bindings.forEach(b => b.unmount(scope, parentScope, mustRemoveRoot));\n\n    switch (true) {\n      // pure components should handle the DOM unmount updates by themselves\n      // for mustRemoveRoot === null don't touch the DOM\n      case el[IS_PURE_SYMBOL] || mustRemoveRoot === null:\n        break;\n      // if children are declared, clear them\n      // applicable for <template> and <slot/> bindings\n\n      case Array.isArray(this.children):\n        clearChildren(this.children);\n        break;\n      // clean the node children only\n\n      case !mustRemoveRoot:\n        cleanNode(el);\n        break;\n      // remove the root node only if the mustRemoveRoot is truly\n\n      case !!mustRemoveRoot:\n        removeChild(el);\n        break;\n    }\n\n    this.el = null;\n    return this;\n  },\n\n  /**\n   * Clone the template chunk\n   * @returns {TemplateChunk} a clone of this object resetting the this.el property\n   */\n  clone() {\n    return Object.assign({}, this, {\n      meta: {},\n      el: null\n    });\n  }\n\n});\n/**\n * Create a template chunk wiring also the bindings\n * @param   {string|HTMLElement} html - template string\n * @param   {BindingData[]} bindings - bindings collection\n * @returns {TemplateChunk} a new TemplateChunk copy\n */\n\nfunction create(html, bindings) {\n  if (bindings === void 0) {\n    bindings = [];\n  }\n\n  return Object.assign({}, TemplateChunk, {\n    html,\n    bindingsData: bindings\n  });\n}\n\n/**\n * Method used to bind expressions to a DOM node\n * @param   {string|HTMLElement} html - your static template html structure\n * @param   {Array} bindings - list of the expressions to bind to update the markup\n * @returns {TemplateChunk} a new TemplateChunk object having the `update`,`mount`, `unmount` and `clone` methods\n *\n * @example\n *\n * riotDOMBindings\n *  .template(\n *   `<div expr0><!----></div><div><p expr1><!----><section expr2></section></p>`,\n *   [\n *     {\n *       selector: '[expr0]',\n *       redundantAttribute: 'expr0',\n *       expressions: [\n *         {\n *           type: expressionTypes.TEXT,\n *           childNodeIndex: 0,\n *           evaluate(scope) {\n *             return scope.time;\n *           },\n *         },\n *       ],\n *     },\n *     {\n *       selector: '[expr1]',\n *       redundantAttribute: 'expr1',\n *       expressions: [\n *         {\n *           type: expressionTypes.TEXT,\n *           childNodeIndex: 0,\n *           evaluate(scope) {\n *             return scope.name;\n *           },\n *         },\n *         {\n *           type: 'attribute',\n *           name: 'style',\n *           evaluate(scope) {\n *             return scope.style;\n *           },\n *         },\n *       ],\n *     },\n *     {\n *       selector: '[expr2]',\n *       redundantAttribute: 'expr2',\n *       type: bindingTypes.IF,\n *       evaluate(scope) {\n *         return scope.isVisible;\n *       },\n *       template: riotDOMBindings.template('hello there'),\n *     },\n *   ]\n * )\n */\n\nvar DOMBindings = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  template: create,\n  createBinding: create$1,\n  createExpression: create$4,\n  bindingTypes: bindingTypes,\n  expressionTypes: expressionTypes\n});\n\nfunction noop() {\n  return this;\n}\n/**\n * Autobind the methods of a source object to itself\n * @param   {Object} source - probably a riot tag instance\n * @param   {Array<string>} methods - list of the methods to autobind\n * @returns {Object} the original object received\n */\n\nfunction autobindMethods(source, methods) {\n  methods.forEach(method => {\n    source[method] = source[method].bind(source);\n  });\n  return source;\n}\n/**\n * Call the first argument received only if it's a function otherwise return it as it is\n * @param   {*} source - anything\n * @returns {*} anything\n */\n\nfunction callOrAssign(source) {\n  return isFunction(source) ? source.prototype && source.prototype.constructor ? new source() : source() : source;\n}\n\n/**\n * Converts any DOM node/s to a loopable array\n * @param   { HTMLElement|NodeList } els - single html element or a node list\n * @returns { Array } always a loopable object\n */\nfunction domToArray(els) {\n  // can this object be already looped?\n  if (!Array.isArray(els)) {\n    // is it a node list?\n    if (/^\\[object (HTMLCollection|NodeList|Object)\\]$/.test(Object.prototype.toString.call(els)) && typeof els.length === 'number') return Array.from(els);else // if it's a single node\n      // it will be returned as \"array\" with one single entry\n      return [els];\n  } // this object could be looped out of the box\n\n\n  return els;\n}\n\n/**\n * Simple helper to find DOM nodes returning them as array like loopable object\n * @param   { string|DOMNodeList } selector - either the query or the DOM nodes to arraify\n * @param   { HTMLElement }        ctx      - context defining where the query will search for the DOM nodes\n * @returns { Array } DOM nodes found as array\n */\n\nfunction $(selector, ctx) {\n  return domToArray(typeof selector === 'string' ? (ctx || document).querySelectorAll(selector) : selector);\n}\n\n/**\n * Normalize the return values, in case of a single value we avoid to return an array\n * @param   { Array } values - list of values we want to return\n * @returns { Array|string|boolean } either the whole list of values or the single one found\n * @private\n */\n\nconst normalize = values => values.length === 1 ? values[0] : values;\n/**\n * Parse all the nodes received to get/remove/check their attributes\n * @param   { HTMLElement|NodeList|Array } els    - DOM node/s to parse\n * @param   { string|Array }               name   - name or list of attributes\n * @param   { string }                     method - method that will be used to parse the attributes\n * @returns { Array|string } result of the parsing in a list or a single value\n * @private\n */\n\n\nfunction parseNodes(els, name, method) {\n  const names = typeof name === 'string' ? [name] : name;\n  return normalize(domToArray(els).map(el => {\n    return normalize(names.map(n => el[method](n)));\n  }));\n}\n/**\n * Set any attribute on a single or a list of DOM nodes\n * @param   { HTMLElement|NodeList|Array } els   - DOM node/s to parse\n * @param   { string|Object }              name  - either the name of the attribute to set\n *                                                 or a list of properties as object key - value\n * @param   { string }                     value - the new value of the attribute (optional)\n * @returns { HTMLElement|NodeList|Array } the original array of elements passed to this function\n *\n * @example\n *\n * import { set } from 'bianco.attr'\n *\n * const img = document.createElement('img')\n *\n * set(img, 'width', 100)\n *\n * // or also\n * set(img, {\n *   width: 300,\n *   height: 300\n * })\n *\n */\n\n\nfunction set(els, name, value) {\n  const attrs = typeof name === 'object' ? name : {\n    [name]: value\n  };\n  const props = Object.keys(attrs);\n  domToArray(els).forEach(el => {\n    props.forEach(prop => el.setAttribute(prop, attrs[prop]));\n  });\n  return els;\n}\n/**\n * Get any attribute from a single or a list of DOM nodes\n * @param   { HTMLElement|NodeList|Array } els   - DOM node/s to parse\n * @param   { string|Array }               name  - name or list of attributes to get\n * @returns { Array|string } list of the attributes found\n *\n * @example\n *\n * import { get } from 'bianco.attr'\n *\n * const img = document.createElement('img')\n *\n * get(img, 'width') // => '200'\n *\n * // or also\n * get(img, ['width', 'height']) // => ['200', '300']\n *\n * // or also\n * get([img1, img2], ['width', 'height']) // => [['200', '300'], ['500', '200']]\n */\n\nfunction get(els, name) {\n  return parseNodes(els, name, 'getAttribute');\n}\n\nconst CSS_BY_NAME = new Map();\nconst STYLE_NODE_SELECTOR = 'style[riot]'; // memoized curried function\n\nconst getStyleNode = (style => {\n  return () => {\n    // lazy evaluation:\n    // if this function was already called before\n    // we return its cached result\n    if (style) return style; // create a new style element or use an existing one\n    // and cache it internally\n\n    style = $(STYLE_NODE_SELECTOR)[0] || document.createElement('style');\n    set(style, 'type', 'text/css');\n    /* istanbul ignore next */\n\n    if (!style.parentNode) document.head.appendChild(style);\n    return style;\n  };\n})();\n/**\n * Object that will be used to inject and manage the css of every tag instance\n */\n\n\nvar cssManager = {\n  CSS_BY_NAME,\n\n  /**\n   * Save a tag style to be later injected into DOM\n   * @param { string } name - if it's passed we will map the css to a tagname\n   * @param { string } css - css string\n   * @returns {Object} self\n   */\n  add(name, css) {\n    if (!CSS_BY_NAME.has(name)) {\n      CSS_BY_NAME.set(name, css);\n      this.inject();\n    }\n\n    return this;\n  },\n\n  /**\n   * Inject all previously saved tag styles into DOM\n   * innerHTML seems slow: http://jsperf.com/riot-insert-style\n   * @returns {Object} self\n   */\n  inject() {\n    getStyleNode().innerHTML = [...CSS_BY_NAME.values()].join('\\n');\n    return this;\n  },\n\n  /**\n   * Remove a tag style from the DOM\n   * @param {string} name a registered tagname\n   * @returns {Object} self\n   */\n  remove(name) {\n    if (CSS_BY_NAME.has(name)) {\n      CSS_BY_NAME.delete(name);\n      this.inject();\n    }\n\n    return this;\n  }\n\n};\n\n/**\n * Function to curry any javascript method\n * @param   {Function}  fn - the target function we want to curry\n * @param   {...[args]} acc - initial arguments\n * @returns {Function|*} it will return a function until the target function\n *                       will receive all of its arguments\n */\nfunction curry(fn) {\n  for (var _len = arguments.length, acc = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    acc[_key - 1] = arguments[_key];\n  }\n\n  return function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    args = [...acc, ...args];\n    return args.length < fn.length ? curry(fn, ...args) : fn(...args);\n  };\n}\n\n/**\n * Get the tag name of any DOM node\n * @param   {HTMLElement} element - DOM node we want to inspect\n * @returns {string} name to identify this dom node in riot\n */\n\nfunction getName(element) {\n  return get(element, IS_DIRECTIVE) || element.tagName.toLowerCase();\n}\n\nconst COMPONENT_CORE_HELPERS = Object.freeze({\n  // component helpers\n  $(selector) {\n    return $(selector, this.root)[0];\n  },\n\n  $$(selector) {\n    return $(selector, this.root);\n  }\n\n});\nconst PURE_COMPONENT_API = Object.freeze({\n  [MOUNT_METHOD_KEY]: noop,\n  [UPDATE_METHOD_KEY]: noop,\n  [UNMOUNT_METHOD_KEY]: noop\n});\nconst COMPONENT_LIFECYCLE_METHODS = Object.freeze({\n  [SHOULD_UPDATE_KEY]: noop,\n  [ON_BEFORE_MOUNT_KEY]: noop,\n  [ON_MOUNTED_KEY]: noop,\n  [ON_BEFORE_UPDATE_KEY]: noop,\n  [ON_UPDATED_KEY]: noop,\n  [ON_BEFORE_UNMOUNT_KEY]: noop,\n  [ON_UNMOUNTED_KEY]: noop\n});\nconst MOCKED_TEMPLATE_INTERFACE = Object.assign({}, PURE_COMPONENT_API, {\n  clone: noop,\n  createDOM: noop\n});\n/**\n * Performance optimization for the recursive components\n * @param  {RiotComponentWrapper} componentWrapper - riot compiler generated object\n * @returns {Object} component like interface\n */\n\nconst memoizedCreateComponent = memoize(createComponent);\n/**\n * Evaluate the component properties either from its real attributes or from its initial user properties\n * @param   {HTMLElement} element - component root\n * @param   {Object}  initialProps - initial props\n * @returns {Object} component props key value pairs\n */\n\nfunction evaluateInitialProps(element, initialProps) {\n  if (initialProps === void 0) {\n    initialProps = {};\n  }\n\n  return Object.assign({}, DOMattributesToObject(element), callOrAssign(initialProps));\n}\n/**\n * Bind a DOM node to its component object\n * @param   {HTMLElement} node - html node mounted\n * @param   {Object} component - Riot.js component object\n * @returns {Object} the component object received as second argument\n */\n\n\nconst bindDOMNodeToComponentObject = (node, component) => node[DOM_COMPONENT_INSTANCE_PROPERTY$1] = component;\n/**\n * Wrap the Riot.js core API methods using a mapping function\n * @param   {Function} mapFunction - lifting function\n * @returns {Object} an object having the { mount, update, unmount } functions\n */\n\n\nfunction createCoreAPIMethods(mapFunction) {\n  return [MOUNT_METHOD_KEY, UPDATE_METHOD_KEY, UNMOUNT_METHOD_KEY].reduce((acc, method) => {\n    acc[method] = mapFunction(method);\n    return acc;\n  }, {});\n}\n/**\n * Factory function to create the component templates only once\n * @param   {Function} template - component template creation function\n * @param   {RiotComponentWrapper} componentWrapper - riot compiler generated object\n * @returns {TemplateChunk} template chunk object\n */\n\n\nfunction componentTemplateFactory(template, componentWrapper) {\n  const components = createSubcomponents(componentWrapper.exports ? componentWrapper.exports.components : {});\n  return template(create, expressionTypes, bindingTypes, name => {\n    // improve support for recursive components\n    if (name === componentWrapper.name) return memoizedCreateComponent(componentWrapper); // return the registered components\n\n    return components[name] || COMPONENTS_IMPLEMENTATION_MAP$1.get(name);\n  });\n}\n/**\n * Create a pure component\n * @param   {Function} pureFactoryFunction - pure component factory function\n * @param   {Array} options.slots - component slots\n * @param   {Array} options.attributes - component attributes\n * @param   {Array} options.template - template factory function\n * @param   {Array} options.template - template factory function\n * @param   {any} options.props - initial component properties\n * @returns {Object} pure component object\n */\n\n\nfunction createPureComponent(pureFactoryFunction, _ref) {\n  let {\n    slots,\n    attributes,\n    props,\n    css,\n    template\n  } = _ref;\n  if (template) panic('Pure components can not have html');\n  if (css) panic('Pure components do not have css');\n  const component = defineDefaults(pureFactoryFunction({\n    slots,\n    attributes,\n    props\n  }), PURE_COMPONENT_API);\n  return createCoreAPIMethods(method => function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    // intercept the mount calls to bind the DOM node to the pure object created\n    // see also https://github.com/riot/riot/issues/2806\n    if (method === MOUNT_METHOD_KEY) {\n      const [element] = args; // mark this node as pure element\n\n      defineProperty(element, IS_PURE_SYMBOL, true);\n      bindDOMNodeToComponentObject(element, component);\n    }\n\n    component[method](...args);\n    return component;\n  });\n}\n/**\n * Create the component interface needed for the @riotjs/dom-bindings tag bindings\n * @param   {RiotComponentWrapper} componentWrapper - riot compiler generated object\n * @param   {string} componentWrapper.css - component css\n * @param   {Function} componentWrapper.template - function that will return the dom-bindings template function\n * @param   {Object} componentWrapper.exports - component interface\n * @param   {string} componentWrapper.name - component name\n * @returns {Object} component like interface\n */\n\n\nfunction createComponent(componentWrapper) {\n  const {\n    css,\n    template,\n    exports,\n    name\n  } = componentWrapper;\n  const templateFn = template ? componentTemplateFactory(template, componentWrapper) : MOCKED_TEMPLATE_INTERFACE;\n  return _ref2 => {\n    let {\n      slots,\n      attributes,\n      props\n    } = _ref2;\n    // pure components rendering will be managed by the end user\n    if (exports && exports[IS_PURE_SYMBOL]) return createPureComponent(exports, {\n      slots,\n      attributes,\n      props,\n      css,\n      template\n    });\n    const componentAPI = callOrAssign(exports) || {};\n    const component = defineComponent({\n      css,\n      template: templateFn,\n      componentAPI,\n      name\n    })({\n      slots,\n      attributes,\n      props\n    }); // notice that for the components create via tag binding\n    // we need to invert the mount (state/parentScope) arguments\n    // the template bindings will only forward the parentScope updates\n    // and never deal with the component state\n\n    return {\n      mount(element, parentScope, state) {\n        return component.mount(element, state, parentScope);\n      },\n\n      update(parentScope, state) {\n        return component.update(state, parentScope);\n      },\n\n      unmount(preserveRoot) {\n        return component.unmount(preserveRoot);\n      }\n\n    };\n  };\n}\n/**\n * Component definition function\n * @param   {Object} implementation - the componen implementation will be generated via compiler\n * @param   {Object} component - the component initial properties\n * @returns {Object} a new component implementation object\n */\n\nfunction defineComponent(_ref3) {\n  let {\n    css,\n    template,\n    componentAPI,\n    name\n  } = _ref3;\n  // add the component css into the DOM\n  if (css && name) cssManager.add(name, css);\n  return curry(enhanceComponentAPI)(defineProperties( // set the component defaults without overriding the original component API\n  defineDefaults(componentAPI, Object.assign({}, COMPONENT_LIFECYCLE_METHODS, {\n    [PROPS_KEY]: {},\n    [STATE_KEY]: {}\n  })), Object.assign({\n    // defined during the component creation\n    [SLOTS_KEY]: null,\n    [ROOT_KEY]: null\n  }, COMPONENT_CORE_HELPERS, {\n    name,\n    css,\n    template\n  })));\n}\n/**\n * Create the bindings to update the component attributes\n * @param   {HTMLElement} node - node where we will bind the expressions\n * @param   {Array} attributes - list of attribute bindings\n * @returns {TemplateChunk} - template bindings object\n */\n\nfunction createAttributeBindings(node, attributes) {\n  if (attributes === void 0) {\n    attributes = [];\n  }\n\n  const expressions = attributes.map(a => create$4(node, a));\n  const binding = {};\n  return Object.assign(binding, Object.assign({\n    expressions\n  }, createCoreAPIMethods(method => scope => {\n    expressions.forEach(e => e[method](scope));\n    return binding;\n  })));\n}\n/**\n * Create the subcomponents that can be included inside a tag in runtime\n * @param   {Object} components - components imported in runtime\n * @returns {Object} all the components transformed into Riot.Component factory functions\n */\n\n\nfunction createSubcomponents(components) {\n  if (components === void 0) {\n    components = {};\n  }\n\n  return Object.entries(callOrAssign(components)).reduce((acc, _ref4) => {\n    let [key, value] = _ref4;\n    acc[camelToDashCase(key)] = createComponent(value);\n    return acc;\n  }, {});\n}\n/**\n * Run the component instance through all the plugins set by the user\n * @param   {Object} component - component instance\n * @returns {Object} the component enhanced by the plugins\n */\n\n\nfunction runPlugins(component) {\n  return [...PLUGINS_SET$1].reduce((c, fn) => fn(c) || c, component);\n}\n/**\n * Compute the component current state merging it with its previous state\n * @param   {Object} oldState - previous state object\n * @param   {Object} newState - new state givent to the `update` call\n * @returns {Object} new object state\n */\n\n\nfunction computeState(oldState, newState) {\n  return Object.assign({}, oldState, callOrAssign(newState));\n}\n/**\n * Add eventually the \"is\" attribute to link this DOM node to its css\n * @param {HTMLElement} element - target root node\n * @param {string} name - name of the component mounted\n * @returns {undefined} it's a void function\n */\n\n\nfunction addCssHook(element, name) {\n  if (getName(element) !== name) {\n    set(element, IS_DIRECTIVE, name);\n  }\n}\n/**\n * Component creation factory function that will enhance the user provided API\n * @param   {Object} component - a component implementation previously defined\n * @param   {Array} options.slots - component slots generated via riot compiler\n * @param   {Array} options.attributes - attribute expressions generated via riot compiler\n * @returns {Riot.Component} a riot component instance\n */\n\n\nfunction enhanceComponentAPI(component, _ref5) {\n  let {\n    slots,\n    attributes,\n    props\n  } = _ref5;\n  return autobindMethods(runPlugins(defineProperties(isObject(component) ? Object.create(component) : component, {\n    mount(element, state, parentScope) {\n      if (state === void 0) {\n        state = {};\n      }\n\n      // any element mounted passing through this function can't be a pure component\n      defineProperty(element, IS_PURE_SYMBOL, false);\n      this[PARENT_KEY_SYMBOL] = parentScope;\n      this[ATTRIBUTES_KEY_SYMBOL] = createAttributeBindings(element, attributes).mount(parentScope);\n      defineProperty(this, PROPS_KEY, Object.freeze(Object.assign({}, evaluateInitialProps(element, props), evaluateAttributeExpressions(this[ATTRIBUTES_KEY_SYMBOL].expressions))));\n      this[STATE_KEY] = computeState(this[STATE_KEY], state);\n      this[TEMPLATE_KEY_SYMBOL] = this.template.createDOM(element).clone(); // link this object to the DOM node\n\n      bindDOMNodeToComponentObject(element, this); // add eventually the 'is' attribute\n\n      component.name && addCssHook(element, component.name); // define the root element\n\n      defineProperty(this, ROOT_KEY, element); // define the slots array\n\n      defineProperty(this, SLOTS_KEY, slots); // before mount lifecycle event\n\n      this[ON_BEFORE_MOUNT_KEY](this[PROPS_KEY], this[STATE_KEY]); // mount the template\n\n      this[TEMPLATE_KEY_SYMBOL].mount(element, this, parentScope);\n      this[ON_MOUNTED_KEY](this[PROPS_KEY], this[STATE_KEY]);\n      return this;\n    },\n\n    update(state, parentScope) {\n      if (state === void 0) {\n        state = {};\n      }\n\n      if (parentScope) {\n        this[PARENT_KEY_SYMBOL] = parentScope;\n        this[ATTRIBUTES_KEY_SYMBOL].update(parentScope);\n      }\n\n      const newProps = evaluateAttributeExpressions(this[ATTRIBUTES_KEY_SYMBOL].expressions);\n      if (this[SHOULD_UPDATE_KEY](newProps, this[PROPS_KEY]) === false) return;\n      defineProperty(this, PROPS_KEY, Object.freeze(Object.assign({}, this[PROPS_KEY], newProps)));\n      this[STATE_KEY] = computeState(this[STATE_KEY], state);\n      this[ON_BEFORE_UPDATE_KEY](this[PROPS_KEY], this[STATE_KEY]); // avoiding recursive updates\n      // see also https://github.com/riot/riot/issues/2895\n\n      if (!this[IS_COMPONENT_UPDATING]) {\n        this[IS_COMPONENT_UPDATING] = true;\n        this[TEMPLATE_KEY_SYMBOL].update(this, this[PARENT_KEY_SYMBOL]);\n      }\n\n      this[ON_UPDATED_KEY](this[PROPS_KEY], this[STATE_KEY]);\n      this[IS_COMPONENT_UPDATING] = false;\n      return this;\n    },\n\n    unmount(preserveRoot) {\n      this[ON_BEFORE_UNMOUNT_KEY](this[PROPS_KEY], this[STATE_KEY]);\n      this[ATTRIBUTES_KEY_SYMBOL].unmount(); // if the preserveRoot is null the template html will be left untouched\n      // in that case the DOM cleanup will happen differently from a parent node\n\n      this[TEMPLATE_KEY_SYMBOL].unmount(this, this[PARENT_KEY_SYMBOL], preserveRoot === null ? null : !preserveRoot);\n      this[ON_UNMOUNTED_KEY](this[PROPS_KEY], this[STATE_KEY]);\n      return this;\n    }\n\n  })), Object.keys(component).filter(prop => isFunction(component[prop])));\n}\n/**\n * Component initialization function starting from a DOM node\n * @param   {HTMLElement} element - element to upgrade\n * @param   {Object} initialProps - initial component properties\n * @param   {string} componentName - component id\n * @returns {Object} a new component instance bound to a DOM node\n */\n\nfunction mountComponent(element, initialProps, componentName) {\n  const name = componentName || getName(element);\n  if (!COMPONENTS_IMPLEMENTATION_MAP$1.has(name)) panic(`The component named \"${name}\" was never registered`);\n  const component = COMPONENTS_IMPLEMENTATION_MAP$1.get(name)({\n    props: initialProps\n  });\n  return component.mount(element);\n}\n\n/**\n * Similar to compose but performs from left-to-right function composition.<br/>\n * {@link https://30secondsofcode.org/function#composeright see also}\n * @param   {...[function]} fns) - list of unary function\n * @returns {*} result of the computation\n */\n/**\n * Performs right-to-left function composition.<br/>\n * Use Array.prototype.reduce() to perform right-to-left function composition.<br/>\n * The last (rightmost) function can accept one or more arguments; the remaining functions must be unary.<br/>\n * {@link https://30secondsofcode.org/function#compose original source code}\n * @param   {...[function]} fns) - list of unary function\n * @returns {*} result of the computation\n */\n\nfunction compose() {\n  for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    fns[_key2] = arguments[_key2];\n  }\n\n  return fns.reduce((f, g) => function () {\n    return f(g(...arguments));\n  });\n}\n\nconst {\n  DOM_COMPONENT_INSTANCE_PROPERTY,\n  COMPONENTS_IMPLEMENTATION_MAP,\n  PLUGINS_SET\n} = globals;\n/**\n * Riot public api\n */\n\n/**\n * Register a custom tag by name\n * @param   {string} name - component name\n * @param   {Object} implementation - tag implementation\n * @returns {Map} map containing all the components implementations\n */\n\nfunction register(name, _ref) {\n  let {\n    css,\n    template,\n    exports\n  } = _ref;\n  if (COMPONENTS_IMPLEMENTATION_MAP.has(name)) panic(`The component \"${name}\" was already registered`);\n  COMPONENTS_IMPLEMENTATION_MAP.set(name, createComponent({\n    name,\n    css,\n    template,\n    exports\n  }));\n  return COMPONENTS_IMPLEMENTATION_MAP;\n}\n/**\n * Unregister a riot web component\n * @param   {string} name - component name\n * @returns {Map} map containing all the components implementations\n */\n\nfunction unregister(name) {\n  if (!COMPONENTS_IMPLEMENTATION_MAP.has(name)) panic(`The component \"${name}\" was never registered`);\n  COMPONENTS_IMPLEMENTATION_MAP.delete(name);\n  cssManager.remove(name);\n  return COMPONENTS_IMPLEMENTATION_MAP;\n}\n/**\n * Mounting function that will work only for the components that were globally registered\n * @param   {string|HTMLElement} selector - query for the selection or a DOM element\n * @param   {Object} initialProps - the initial component properties\n * @param   {string} name - optional component name\n * @returns {Array} list of riot components\n */\n\nfunction mount(selector, initialProps, name) {\n  return $(selector).map(element => mountComponent(element, initialProps, name));\n}\n/**\n * Sweet unmounting helper function for the DOM node mounted manually by the user\n * @param   {string|HTMLElement} selector - query for the selection or a DOM element\n * @param   {boolean|null} keepRootElement - if true keep the root element\n * @returns {Array} list of nodes unmounted\n */\n\nfunction unmount(selector, keepRootElement) {\n  return $(selector).map(element => {\n    if (element[DOM_COMPONENT_INSTANCE_PROPERTY]) {\n      element[DOM_COMPONENT_INSTANCE_PROPERTY].unmount(keepRootElement);\n    }\n\n    return element;\n  });\n}\n/**\n * Define a riot plugin\n * @param   {Function} plugin - function that will receive all the components created\n * @returns {Set} the set containing all the plugins installed\n */\n\nfunction install(plugin) {\n  if (!isFunction(plugin)) panic('Plugins must be of type function');\n  if (PLUGINS_SET.has(plugin)) panic('This plugin was already installed');\n  PLUGINS_SET.add(plugin);\n  return PLUGINS_SET;\n}\n/**\n * Uninstall a riot plugin\n * @param   {Function} plugin - plugin previously installed\n * @returns {Set} the set containing all the plugins installed\n */\n\nfunction uninstall(plugin) {\n  if (!PLUGINS_SET.has(plugin)) panic('This plugin was never installed');\n  PLUGINS_SET.delete(plugin);\n  return PLUGINS_SET;\n}\n/**\n * Helper method to create component without relying on the registered ones\n * @param   {Object} implementation - component implementation\n * @returns {Function} function that will allow you to mount a riot component on a DOM node\n */\n\nfunction component(implementation) {\n  return function (el, props, _temp) {\n    let {\n      slots,\n      attributes,\n      parentScope\n    } = _temp === void 0 ? {} : _temp;\n    return compose(c => c.mount(el, parentScope), c => c({\n      props,\n      slots,\n      attributes\n    }), createComponent)(implementation);\n  };\n}\n/**\n * Lift a riot component Interface into a pure riot object\n * @param   {Function} func - RiotPureComponent factory function\n * @returns {Function} the lifted original function received as argument\n */\n\nfunction pure(func) {\n  if (!isFunction(func)) panic('riot.pure accepts only arguments of type \"function\"');\n  func[IS_PURE_SYMBOL] = true;\n  return func;\n}\n/**\n * no-op function needed to add the proper types to your component via typescript\n * @param {Function|Object} component - component default export\n * @returns {Function|Object} returns exactly what it has received\n */\n\nconst withTypes = component => component;\n/** @type {string} current riot version */\n\nconst version = 'v6.0.2'; // expose some internal stuff that might be used from external tools\n\nconst __ = {\n  cssManager,\n  DOMBindings,\n  createComponent,\n  defineComponent,\n  globals\n};\n\nexport { __, component, install, mount, pure, register, uninstall, unmount, unregister, version, withTypes };\n","var map = {\n\t\"./test-component.riot\": 990\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 329;"],"names":["exports","riot","$","_interopDefaultLegacy","e","$__default","cssManager","__","DOM_COMPONENT_INSTANCE_PROPERTY","globals","reload","componentAPI","name","map","el","oldTag","unmount","remove","newTag","component","props","update","state","console","warn","default","Object","defineProperty","value","factory","window","undefined","ALL_CALLBACKS","define","defineProperties","entries","on","callbacks","event","fn","has","get","add","set","Set","off","fns","delete","size","clear","one","args","apply","trigger","forEach","module","Map","reduce","acc","key","method","enumerable","writable","configurable","rawResponse","fetch","headers","body","JSON","stringify","a","b","content","json","log","globalComponentsContext","require","keys","path","extension","split","reverse","replace","basename","register","mount","selector","ctx","els","document","querySelectorAll","Array","isArray","test","prototype","toString","call","length","from","normalizeUrl","srcByModuleId","create","noDocument","noop","updateCss","url","href","isUrlRequest","isLoaded","indexOf","visited","newEl","cloneNode","addEventListener","parentNode","removeChild","concat","Date","now","nextSibling","insertBefore","appendChild","reloadAll","elements","moduleId","options","timeout","getScriptSrc","src","currentScript","scripts","getElementsByTagName","lastScriptTag","fileMap","splitResult","filename","mapRule","reg","RegExp","getCurrentScriptUrl","reloaded","loaded","ret","stripWWW","some","getReloadUrl","reloadStyle","locals","join","self","this","arguments","functionCall","clearTimeout","setTimeout","urlString","trim","protocol","components","host","toLowerCase","accumulator","item","pop","push","cssReload","id","hot","dispose","accept","runtime","Op","hasOwn","hasOwnProperty","$Symbol","Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","obj","err","wrap","innerFn","outerFn","tryLocsList","protoGenerator","Generator","generator","context","Context","_invoke","GenStateSuspendedStart","arg","GenStateExecuting","Error","GenStateCompleted","doneResult","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","type","done","GenStateSuspendedYield","makeInvokeMethod","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","AsyncIterator","PromiseImpl","invoke","resolve","reject","result","__await","then","unwrapped","error","previousPromise","callInvokeWithMethodAndArg","TypeError","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","i","constructor","displayName","isGeneratorFunction","genFun","ctor","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","object","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","thrown","delegateYield","regeneratorRuntime","accidentalStrictMode","Function","dashToCamelCase","string","_","c","toUpperCase","moveChildren","source","target","firstChild","cleanNode","node","clearChildren","childNodes","children","newNode","refNode","COMPONENTS_IMPLEMENTATION_MAP$1","DOM_COMPONENT_INSTANCE_PROPERTY$1","PLUGINS_SET$1","IS_DIRECTIVE","MOUNT_METHOD_KEY","UPDATE_METHOD_KEY","UNMOUNT_METHOD_KEY","SHOULD_UPDATE_KEY","ON_BEFORE_MOUNT_KEY","ON_MOUNTED_KEY","ON_BEFORE_UPDATE_KEY","ON_UPDATED_KEY","ON_BEFORE_UNMOUNT_KEY","ON_UNMOUNTED_KEY","PROPS_KEY","STATE_KEY","SLOTS_KEY","ROOT_KEY","IS_PURE_SYMBOL","IS_COMPONENT_UPDATING","PARENT_KEY_SYMBOL","ATTRIBUTES_KEY_SYMBOL","TEMPLATE_KEY_SYMBOL","freeze","COMPONENTS_IMPLEMENTATION_MAP","PLUGINS_SET","VALUE_ATTRIBUTE","bindingTypes","EACH","IF","SIMPLE","TAG","SLOT","expressionTypes","ATTRIBUTE","EVENT","TEXT","VALUE","HEAD_SYMBOL","TAIL_SYMBOL","assign","properties","_ref","defineDefaults","defaults","_ref2","getFragmentChildren","head","tail","nodes","walkNodes","n","check","isFilterActive","checkType","element","isSvg","owner","ownerSVGElement","isTemplate","tagName","isFunction","isObject","isNil","UNMOUNT_SCOPE","EachBinding","scope","parentScope","placeholder","childrenMap","collection","evaluate","items","newChildrenMap","batches","futureNodes","binding","condition","template","itemName","getKey","indexName","root","isTemplateTag","index","extendScope","oldItem","mustFilterItem","mustMount","componentTemplate","clone","meta","fragment","dom","createTextNode","createHeadTailPlaceholders","avoidDOMInjection","createTemplateMeta","createPatch","before","bLength","aEnd","bEnd","aStart","bStart","sequence","replaced","replaceChild","udomdiff","redundant","patch","first","last","markEdgeNodes","IfBinding","mustUnmount","pristine","panic","message","memoize","cache","cached","val","evaluateAttributeExpressions","attributes","attribute","ElementProto","Element","isNativeHtmlProperty","RE_EVENTS_PREFIX","EventListener","handleEvent","ListenersWeakMap","WeakMap","normalizeStringValue","getTextNode","childNodeIndex","nodeType","Node","COMMENT_NODE","textNode","expressions","attributeExpression","oldValue","newAttributes","oldAttributes","newKeys","filter","includes","removeAttribute","removeAllAttributes","setAllAttributes","isBoolean","shouldRemoveAttribute","canRenderAttribute","setAttribute","normalizeValue","normalizedEventName","eventListener","listener","createListener","callback","getCallbackAndOptions","handler","mustAddEvent","removeEventListener","data","expression","Expression","create$4","getRealParent","SlotBinding","getTemplateScope","attr","extendParentScope","templateData","slots","find","realParent","html","bindings","createDOM","moveSlotInnerContent","mustRemoveRoot","slot","child","slotBindings","TagBinding","tag","slotsToMarkup","getTag","getComponent","keepRootTag","fixTextExpressionsOffset","textExpressionsOffset","create$1","templateTagOffset","redundantAttribute","querySelector","bindingExpressions","injectDOM","TemplateChunk","container","ownerDocument","importNode","DOMParser","parseFromString","documentElement","createSVGTree","createElement","innerHTML","createHTMLTree","createDOMTree","createTemplateDOM","createDocumentFragment","siblings","Math","max","getTemplateTagOffset","bindingsData","DOMBindings","createBinding","createExpression","callOrAssign","domToArray","normalize","attrs","prop","CSS_BY_NAME","style","css","inject","curry","_len","_key","_len2","_key2","getName","names","parseNodes","COMPONENT_CORE_HELPERS","$$","PURE_COMPONENT_API","COMPONENT_LIFECYCLE_METHODS","MOCKED_TEMPLATE_INTERFACE","memoizedCreateComponent","createComponent","bindDOMNodeToComponentObject","createCoreAPIMethods","mapFunction","componentWrapper","templateFn","_ref4","createSubcomponents","componentTemplateFactory","pureFactoryFunction","createPureComponent","defineComponent","preserveRoot","_ref3","enhanceComponentAPI","computeState","oldState","newState","_ref5","runPlugins","createAttributeBindings","initialProps","DOMattributesToObject","evaluateInitialProps","addCssHook","newProps","bind","unregister","componentName","mountComponent","keepRootElement","install","plugin","uninstall","implementation","_temp","f","g","compose","pure","func","withTypes","version","webpackContext","req","webpackContextResolve","__webpack_require__","o","code"],"sourceRoot":""}